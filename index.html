<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Associative Network</title>
    <!-- Plotly.js for creating the 3D graph -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Tailwind CSS for styling the page -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Custom style for select multiple to show all options */
        select[multiple] { height: auto; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <div class="bg-gray-800 border border-gray-700 rounded-xl shadow-lg p-6 md:p-8">
            <h1 class="text-3xl font-bold text-center text-white mb-2">Dynamic Associative Network</h1>
            <p class="text-center text-gray-400 mb-6">An interactive JavaScript implementation of the DAN model. Select properties and run inference.</p>

            <!-- UI Controls -->
            <div id="controls" class="flex flex-wrap justify-center gap-4 mb-6">
                <!-- widgets generated by JS -->
            </div>
            <div class="flex justify-center gap-4 mb-6">
                 <button id="run-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Run Inference</button>
                 <button id="reset-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Reset View</button>
            </div>

             <!-- Results Text Area -->
            <div id="results-output" class="bg-gray-900 border border-gray-700 rounded-lg p-4 mb-6 h-48 overflow-y-auto font-mono text-sm">
                Select properties and click "Run Inference" to see results.
            </div>

            <!-- Container of Plotly graph -->
            <div id="plotly-graph" class="w-full h-[70vh] rounded-lg bg-gray-800"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function () {
        // DATA
        const dataset = {
            "Art":    {"Gang": "Jets", "Age": "40s", "Edu": "JH",  "Marital": "Single",  "Occ": "Pusher"},
            "Al":     {"Gang": "Jets", "Age": "30s", "Edu": "JH",  "Marital": "Married", "Occ": "Burglar"},
            "Sam":    {"Gang": "Jets", "Age": "20s", "Edu": "HS",  "Marital": "Single",  "Occ": "Bookie"},
            "Clyde":  {"Gang": "Jets", "Age": "40s", "Edu": "JH",  "Marital": "Single",  "Occ": "Pusher"},
            "Mike":   {"Gang": "Jets", "Age": "30s", "Edu": "JH",  "Marital": "Single",  "Occ": "Bookie"},
            "Jim":    {"Gang": "Jets", "Age": "20s", "Edu": "JH",  "Marital": "Married", "Occ": "Burglar"},
            "Greg":   {"Gang": "Jets", "Age": "20s", "Edu": "HS",  "Marital": "Single",  "Occ": "Pusher"},
            "John":   {"Gang": "Jets", "Age": "20s", "Edu": "JH",  "Marital": "Married", "Occ": "Burglar"},
            "Doug":   {"Gang": "Jets", "Age": "30s", "Edu": "HS",  "Marital": "Single",  "Occ": "Bookie"},
            "Lance":  {"Gang": "Jets", "Age": "20s", "Edu": "JH",  "Marital": "Married", "Occ": "Burglar"},
            "George": {"Gang": "Jets", "Age": "20s", "Edu": "JH",  "Marital": "Married", "Occ": "Burglar"},
            "Pete":   {"Gang": "Jets", "Age": "20s", "Edu": "HS",  "Marital": "Single",  "Occ": "Bookie"},
            "Fred":   {"Gang": "Jets", "Age": "20s", "Edu": "HS",  "Marital": "Single",  "Occ": "Pusher"},
            "Gene":   {"Gang": "Jets", "Age": "20s", "Edu": "COL", "Marital": "Single",  "Occ": "Pusher"},
            "Ralph":  {"Gang": "Jets", "Age": "30s", "Edu": "JH",  "Marital": "Single",  "Occ": "Pusher"},
            "Bern":   {"Gang": "Sharks", "Age": "40s", "Edu": "HS",  "Marital": "Married", "Occ": "Pusher"},
            "Nick":   {"Gang": "Sharks", "Age": "30s", "Edu": "COL", "Marital": "Single",  "Occ": "Burglar"},
            "Ken":    {"Gang": "Sharks", "Age": "20s", "Edu": "HS",  "Marital": "Married", "Occ": "Bookie"},
            "Ike":    {"Gang": "Sharks", "Age": "30s", "Edu": "JH",  "Marital": "Single",  "Occ": "Bookie"},
            "Don":    {"Gang": "Sharks", "Age": "20s", "Edu": "COL", "Marital": "Married", "Occ": "Burglar"},
            "Ned":    {"Gang": "Sharks", "Age": "30s", "Edu": "COL", "Marital": "Married", "Occ": "Bookie"},
            "Karl":   {"Gang": "Sharks", "Age": "40s", "Edu": "HS",  "Marital": "Married", "Occ": "Pusher"},
            "Earl":   {"Gang": "Sharks", "Age": "30s", "Edu": "HS",  "Marital": "Married", "Occ": "Pusher"},
            "Phil":   {"Gang": "Sharks", "Age": "20s", "Edu": "HS",  "Marital": "Married", "Occ": "Burglar"},
            "Saul":   {"Gang": "Sharks", "Age": "20s", "Edu": "HS",  "Marital": "Single",  "Occ": "Bookie"},
            "Rick":   {"Gang": "Sharks", "Age": "30s", "Edu": "JH",  "Marital": "Single", "Occ": "Pusher"},
        };

        // DATA PROCESSING 
        const personNames = Object.keys(dataset);
        const allProperties = {};
        const propertyToPeople = {};

        personNames.forEach(person => {
            Object.entries(dataset[person]).forEach(([propType, propValue]) => {
                if (!allProperties[propType]) allProperties[propType] = new Set();
                allProperties[propType].add(propValue);

                if (!propertyToPeople[propValue]) propertyToPeople[propValue] = [];
                propertyToPeople[propValue].push(person);
            });
        });

        // DAN Pre-calculation: Diffusion and Peak Activation
        const propertyDiffusion = {};
        Object.keys(propertyToPeople).forEach(prop => {
            const count = propertyToPeople[prop].length;
            propertyDiffusion[prop] = 1 / count;
        });

        const personPeakActivation = {};
        personNames.forEach(person => {
            const personProps = Object.values(dataset[person]);
            const excitation = personProps.reduce((sum, prop) => sum + propertyDiffusion[prop], 0);
            const infusion = 1 / 5.0;
            personPeakActivation[person] = excitation * infusion;
        });
        
        // UI GENERATION
        const controlsContainer = document.getElementById('controls');
        const selectionWidgets = [];
        Object.entries(allProperties).sort().forEach(([propType, propValues]) => {
            const container = document.createElement('div');
            container.className = 'flex flex-col';
            
            const label = document.createElement('label');
            label.textContent = `${propType}:`;
            label.className = 'font-bold mb-1 text-white';
            container.appendChild(label);
            
            const select = document.createElement('select');
            select.multiple = true;
            select.className = 'bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-blue-500 focus:border-blue-500';
            
            Array.from(propValues).sort().forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                option.textContent = val;
                select.appendChild(option);
            });
            container.appendChild(select);
            controlsContainer.appendChild(container);
            selectionWidgets.push(select);
        });

        // VISUALIZATION SETUP 
        const pos = {};
        const radius = 10, angleIncrement = (2 * Math.PI) / personNames.length;
        let currentAngle = 0;
        const categoryPositions = {'Gang': {x: 25, y: 0, z: 0}, 'Age': {x: -25, y: 0, z: 0}, 'Edu': {x: 0, y: 25, z: 0}, 'Marital': {x: 0, y: -25, z: 0}, 'Occ': {x: 0, y: 0, z: 25}};

        personNames.forEach(name => {
            pos[name] = { x: radius * Math.cos(currentAngle), y: radius * Math.sin(currentAngle), z: 0 };
            currentAngle += angleIncrement;
        });

        Object.keys(propertyToPeople).forEach(propName => {
            const propType = Object.keys(allProperties).find(type => allProperties[type].has(propName));
            const catPos = categoryPositions[propType];
            pos[propName] = { x: catPos.x + (Math.random() - 0.5) * 5, y: catPos.y + (Math.random() - 0.5) * 5, z: catPos.z + (Math.random() - 0.5) * 5 };
        });

        const allNodeNames = [...personNames, ...Object.keys(propertyToPeople)];
        const nodeTrace = {
            x: [], y: [], z: [], text: [],
            type: 'scatter3d', mode: 'markers', hoverinfo: 'text',
            marker: { color: [], size: 10, line: { width: 1 } }
        };
        const initialColors = [];
        const categoryColors = {'Person': '#1f77b4', 'Gang': '#ff7f0e', 'Age': '#2ca02c', 'Edu': '#d62728', 'Marital': '#9467bd', 'Occ': '#8c564b'};

        allNodeNames.forEach(name => {
            nodeTrace.x.push(pos[name].x);
            nodeTrace.y.push(pos[name].y);
            nodeTrace.z.push(pos[name].z);
            let type = 'Person';
            if (propertyToPeople[name]) {
                type = Object.keys(allProperties).find(t => allProperties[t].has(name));
            }
            nodeTrace.text.push(`${name}<br>Type: ${type}`);
            initialColors.push(categoryColors[type] || '#7f7f7f');
        });
        nodeTrace.marker.color = [...initialColors];

        const edgeTrace = { x: [], y: [], z: [], type: 'scatter3d', mode: 'lines', line: { width: 0.5, color: '#888' }, hoverinfo: 'none' };
        personNames.forEach(person => {
            Object.values(dataset[person]).forEach(prop => {
                edgeTrace.x.push(pos[person].x, pos[prop].x, null);
                edgeTrace.y.push(pos[person].y, pos[prop].y, null);
                edgeTrace.z.push(pos[person].z, pos[prop].z, null);
            });
        });

        const layout = {
            title: '', showlegend: false, height: 600,
            paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#fff' },
            scene: {
                xaxis: { showgrid: false, zeroline: false, showticklabels: false, title: '' },
                yaxis: { showgrid: false, zeroline: false, showticklabels: false, title: '' },
                zaxis: { showgrid: false, zeroline: false, showticklabels: false, title: '' }
            }
        };

        Plotly.newPlot('plotly-graph', [edgeTrace, nodeTrace], layout, {responsive: true});
        
        // CORE DAN LOGIC AND UI BINDING 
        const runButton = document.getElementById('run-button');
        const resetButton = document.getElementById('reset-button');
        const resultsOutput = document.getElementById('results-output');

        runButton.addEventListener('click', () => {
            const queryProperties = selectionWidgets.flatMap(widget => Array.from(widget.selectedOptions).map(opt => opt.value));

            if (queryProperties.length === 0) {
                resetView();
                return;
            }

            // 1: Properties -> Objects 
            const objectWeights = {};
            const queryInfusion = 1 / queryProperties.length;
            personNames.forEach(person => {
                const personProps = Object.values(dataset[person]);
                const excitation = queryProperties.reduce((sum, qp) => sum + (personProps.includes(qp) ? propertyDiffusion[qp] : 0), 0);
                const activation = excitation * queryInfusion;
                objectWeights[person] = personPeakActivation[person] > 0 ? activation / personPeakActivation[person] : 0;
            });

            // 2: Objects -> Properties 
            const finalPropertyActivations = {};
            Object.keys(propertyToPeople).forEach(p => finalPropertyActivations[p] = 0);
            const objectInfusion = 1 / 5.0;
            personNames.forEach(person => {
                const weight = objectWeights[person];
                Object.values(dataset[person]).forEach(prop => {
                    finalPropertyActivations[prop] += weight * objectInfusion;
                });
            });

            //  Update Visualization and Results 
            const sortedPredictions = Object.entries(finalPropertyActivations).sort((a, b) => b[1] - a[1]);
            const winningProperties = sortedPredictions.filter(([p, s]) => !queryProperties.includes(p)).slice(0, 5).map(([p, s]) => p);

            const updatedColors = allNodeNames.map(name => {
                if (queryProperties.includes(name)) return 'blue';
                if (winningProperties.includes(name)) return 'lime';
                if (personNames.includes(name) && objectWeights[name] > 0.5) return '#ff69b4';
                return '#4a5568'; // Grey out
            });

            Plotly.restyle('plotly-graph', { 'marker.color': [updatedColors] }, [1]);

            resultsOutput.innerHTML = `<h3 class="font-bold text-white mb-2">Inference Results</h3>
                <p><span class="font-semibold">Query:</span> ${queryProperties.join(', ')}</p>
                <h4 class="font-bold text-white mt-3 mb-1">Top Predicted Associations:</h4>
                <ul class="list-disc list-inside">
                    ${sortedPredictions.filter(([p, s]) => !queryProperties.includes(p)).map(([p, s]) => `<li>${p}: ${s.toFixed(4)}</li>`).join('')}
                </ul>`;
        });
        
        const resetView = () => {
             selectionWidgets.forEach(widget => widget.selectedIndex = -1);
             Plotly.restyle('plotly-graph', { 'marker.color': [initialColors] }, [1]);
             resultsOutput.innerHTML = 'Select properties and click "Run Inference" to see results.';
        };

        resetButton.addEventListener('click', resetView);
    });
    </script>
</body>
</html>
